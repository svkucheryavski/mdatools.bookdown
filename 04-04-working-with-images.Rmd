## Working with images {-}

From version 0.8.0 the package also supports images, however they have to be transformed into datasets. The idea
is very simple, we keep information about image pixels in an unfolded form, as a matrix, and use attributes `width`
and `height` to reshape the data when we need to show it as an image.

There are three methods that make this procedure easier: `mda.im2data()`, `mda.data2im()` and `imshow()`. The
first convert an image (represented as 3-way array) to a data set, second does the opposite and the third takes
dataset and shows it as an image. In the code chunk below you will see several examples how the methods work.
We will use a dataset `image` available in the package. It is a 3-way array of numbers, if you want to work 
with e.g. JPEG, PNG or other standard image files you can load them using specific packages ([jpeg](https://cran.r-project.org/web/packages/jpeg/index.html), 
[png](https://cran.r-project.org/web/packages/png/index.html)).

```{r, echo = FALSE}
library(mdatools)
```

```{r, fig.width = 9, fig.height = 9}
data(image)
# convert image to a data matrix and add some attributed
d = mda.im2data(img)
colnames(d) = c('Red', 'Green', 'Blue')
attr(d, 'name') = 'Image'

# show data values 
mda.show(d, 10)

# show separate channels and the whole image in plots
par(mfrow = c(2, 2))
imshow(d, 1)
imshow(d, 2)
imshow(d, 3)
imshow(d, 1:3)
```

You can work with the image values as normal dataset and show scatter, line plots, calculate statistics, etc.

```{r, fig.width = 9, fig.height = 5}
par(mfrow = c(1, 2))
mdaplot(d, type = 'p')
mdaplot(d, type = 'l')
```

However, it will take some time to show these plots as this image has several hundreds of thousands pixels, 
a faster alternative can be the use of `smoothScatter()` function. The `mdaplot()` has a wrapper for the function
(`type = 'd'`).

```{r, fig.width = 9, fig.height = 5}
par(mfrow = c(1, 2))
mdaplot(d, type = 'd')
mdaplot(mda.subset(d, select = c('Red', 'Blue')), type = 'd')
```

Another useful thing is to set some of the pixels as background. The background pixels are removed from the image
dataset physically, there is no way to get them back (in cotrast to excluded rows/pixels). It can be particularly
useful when working with e.g. geocorrected hyperspectral images, where, often, many pixels have NA values and 
there is no need to keep them in memory. To set pixels as background you need to use method `mda.setimbg()` with
either pixel indices or vector with logical values as it is shown below. 

```{r, fig.width = 9, fig.height = 5}

# original size
show(dim(d))

# set red epixels as background and show new size
d = mda.setimbg(d, d[, 'Red'] > 100)
show(dim(d))

# show image with background pixels
par(mfrow = c(1, 2))
imshow(d, 1)
imshow(d, 1:3)
```

You can also exclude pixels as rows in the image dataset. By default the excluded pixels are not shown with 
`imshow()` function, however providing argument `show.excluded = TRUE` you can make them visible as gray
pixels. If you want to see the excluded pixels with original color use `show.excluded = NULL`. Note that once
you exclude any pixels you can not use method `mda.setimbg()`, so define the background pixels first.

```{r, fig.width = 9, fig.height = 9}
d = mda.exclrows(d, d[, 'Green'] > 100)
par(mfrow = c(2, 2))
imshow(d, 1:3)
imshow(d, 2, show.excluded = T)
imshow(d, 1:3, show.excluded = T)
imshow(d, 1:3, show.excluded = NULL)
```

All image related attributes are inherited by all object/rows related results, e.g. scores, residuals, predicted 
values and classes, etc. This means if you provide an image to any modelling method, you can visualise the 
corresponding results also as an image. Some examples will be shown in 
[chapter about PCA][Principal component analysis]

